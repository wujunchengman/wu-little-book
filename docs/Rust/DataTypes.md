---
title: 数据类型
---

# 数据类型

Rust中的数据类型有两类，一类是标量类型，一类是复合类型

## 标量类型

标量类型所占的内存空间是确定的，是最基本的数据类型，这些类型在C#中称为基类型

标量类型包含整形、浮点型、布尔型、字符型

与其他编程语言一样，Rust的整形和浮点型也包含不同大小的细分类型，但是在Rust中，并不是用int表是32位整形、long表示64位整形，而是使用更直观的位表示


| 长度   | 有符号   | 无符号   |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

isize 和 usize是根据架构来的，32位架构是32位，64位架构是64位

浮点数与其他编程语言一样分为32位浮点和64位浮点，不过并不叫float和double，而是叫f32和f64

布尔类型与其他编程语言一样，都是true和false；字符型表示一个字符，不过Rust中的字符是Unicode字符，占四个字节

## 复合类型

复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）；还可以自定义类型

### 元组

元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。

Rust中的元组和C#中的元组定义相似
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

Rust中的元组还支持解构语法
```rust
let (x, y, z) = tup;
```
也可以通过`.`加索引值的方式访问元组中的值
```rust
println!("通过索引值访问元组的第二个元素: {tup.1}");
```

不带任何值的元组有个特殊的名称，叫做 单元（unit） 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。

### 数组

数组中的每个元素类型必须相同，这与其他编程语言相同（排除掉已经不用的Object数组）。

声明数组的方式也是类似的，只是格式上有一点点不同

```rust
// 声明包含5个i32元素的数组，但是没有初始化，直接访问会编译报错
let a = [i32;5];

// 也可以直接提供具体的值声明一个数组，此时a也是一个包含5个元素的数组
let a = [1,2,3,4,5]

// 如果使用相同的元素初始化数组，可以在声明类型的地方替换为具体的值，后面元素数量的定义不变，会初始化为一个包含了指定数量，所有元素都初始化为提供的具体的值的数组
let a = [3;5];
```

访问数组中的元素使用对应的索引值

```rust
let a = [1, 2, 3, 4, 5];

let first = a[0];
let second = a[1];
```

程序在索引操作中使用一个无效的值时导致**运行时**错误

如果需要访问一个不确定是否会越界的数组，可以使用get访问，它会返回一个Option，不会出现**运行时**错误

### 列表（vector）

vector 允许我们一个挨着一个地储存一系列数量可变的值。vector与其他编程语言的List类似

新建一个vector
```rust
// 新建一个空vector
let v: Vec<i32> = Vec::new();

// 通过vec!宏创建含有指定元素的vector，泛型类型自动推断为i32
let v = vec![1, 2, 3];

// 新建空vector并向其中增加元素
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);

```

访问vector则与访问数组类似，可以通过索引和get访问

```rust
let v = vec![1, 2, 3, 4, 5];

// 通过索引访问，如果不是合法的索引值，会导致运行时错误
let third: &i32 = &v[2];
println!("The third element is {third}");

// 通过get访问，返回一个Option，不会导致运行时错误
let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
```

vector不能在拥有其中项的引用的同时增加元素
```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
// 编译器会报错，这是因为vector同其他编程语言一样，vector也是先申请一段空间以数组的方式保存，如果新增元素时容量不够，就申请一个更大的数组空间，将目前的元素复制过去
// 如果在持有项的引用时添加元素导致了扩容复制，则原来的引用地址就不再有效
v.push(6);
```

vector是泛型的，只能保存同一种类型，其他编程语言有非泛型List，但是Rust不提供，当有需要保存不同类型的元素在vector中的需求时，可以借助枚举类型，Rust的枚举类型非常特别，可以包含一个任意类型的值

### 字符串（string）



### 哈希map（hash map）

hashmap允许我们将值与一个特定的键（key）相关联。这是一个叫做 map 的更通用的数据结构的特定实现。


