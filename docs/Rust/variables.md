---
title: Rust中的变量
---

# Rust中的变量

在其他的编程语言中，有可变变量、常量、不可变变量，比如说在C#中，不加修饰符定义的变量是可变变量，使用readonly修饰的变量是不可变变量，使用const修饰的是常量，在Rust中也有对应的可变变量、不可变变量、常量


### C#中常量和变量（常见的面向对象语言中的常量和变量）

```csharp

// readonly字段可以在构造函数和字段声明初始化，可用于运行时常量

// 后面使用timeStamp时不可再改变它的值，但是在首次初始化时可以提供一个变量
public static readonly uint timeStamp = (uint)DateTime.Now.Ticks;

// const只能在声明是初始化值，是编译时常量，因为编译时程序无法确定变量的值，因此为常量初始化时只能使用常量，或者常量表达式，必须是在编译期就能确定的值
const int C = 707;

// 可以使用常量表达式赋初值
const int D = C + 100;

int x = 100;

x = 101;

```

### Rust中的常量、可变变量和不可变变量

```rust

// 如果不加修饰，定义的是不可变变量
let x = 5;

// 使用mut修饰，定义的是可变变量
let mut x = 5;
// 使用mut修饰的是可变变量，可以重新赋值
x = 6;

// 使用const声明常量，必须指定数据类型，Rust 对常量的命名约定是在单词之间使用全大写加下划线
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

```

##### 隐藏

在上面的代码中，有一个寻常面向对象语言不允许的操作：同一作用域使用隐藏

在C#中，在同一作用域中，不能声明相同名称的变量（在不同作用域中可以，也可以在内层作用域声明相同名称的变量隐藏外层作用域的变量），而Rust允许在相同层级隐藏，正如上面的代码中声明了两次`x`。当然，在不同层级也可以声明相同名称变量来隐藏之前的声明，效果与常见的面向对象语言效果相同

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        // x 的值为12
        println!("The value of x in the inner scope is: {x}");
    }

    // 脱离之前的作用域后隐藏的x重新可以获取了，此时x为6
    println!("The value of x is: {x}");
}
```