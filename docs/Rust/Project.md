---
title: 项目管理
---

一个现实中的项目，基本不会出现一个文件就解决了问题，通常都会根据不同的功能、逻辑进行分拆，Rust提供了多种不同范围的作用域，用以更好的管理项目

## 工作空间

## crate

crate是Rust在编译时的最小代码单位，这意味着如果你觉得项目每次编译都耗费大量时间的时候，可以将代码拆分为多个crate，这样没有改动的代码就不会再重复编译，编译速度也会得到提升

crate有两种形式：二进制项和库

二进制项可以被编译为可执行程序，它们必须有一个 main 函数来定义当程序被执行的时候所需要做的事情

库并没有 main 函数，它们也不会编译为可执行程序，它们提供一些诸如函数之类的东西，使其他项目也能使用这些东西。大多数时间 Rustaceans 说的 crate 指的都是库，这与其他编程语言中 library 概念一致

## 包（package）

包（package）是提供一系列功能的一个或者多个 crate。一个包会包含一个 Cargo.toml 文件，阐述如何去构建这些 crate。Cargo 就是一个包含构建你代码的二进制项的包。Cargo 也包含这些二进制项所依赖的库。其他项目也能用 Cargo 库来实现与 Cargo 命令行程序一样的逻辑。

包中可以包含至多一个库 crate(library crate)。包中可以包含任意多个二进制 crate(binary crate)，但是必须至少包含一个 crate（无论是库的还是二进制的）。

创建一个包通常使用`cargo new`命令（Cargo 是 Rust 的构建系统和包管理器，在与C/C++的对比中，Rust不一定说占尽优势，但是Cargo一定是比Make/CMake这些更加现代化的）

cargo对crate的识别通过约定的文件名：`src/main.rs`表示这是一个二进制crate，名字与包名相同；`src/lib.rs`表示这是一个库crate，名字与包名相同



## 模块

模块有点类似C#中的名字空间(namespace)

Cargo在编译时会怎样搜索模块呢？首先是内联，使用`mod <模块名> { }`，大括号内的就是模块内的代码；其次是检查`src/模块名.rs`，根据文件名直接匹配，`模块名.rs`中的代码就是模块中的代码；最后是在`src/模块名/mod.rs`，如果是模块名作为文件夹，则必须要求对应模块名文件夹中有`mod.rs`文件，此时整个文件夹都会作为模块内的代码

当模块不是内联时，只需在模块树中的某处使用一次 mod 声明就可以加载这个文件。一旦编译器知道了这个文件是项目的一部分（并且通过 mod 语句的位置知道了代码在模块树中的位置），项目中的其他文件应该使用其所声明的位置的路径来引用那个文件的代码，这在“引用模块项目的路径”部分有讲到。换句话说，mod 不是 你可能会在其他编程语言中看到的 "include" 操作。

模块是可以嵌套的，最外层的模块搜索时的根文件夹是`src`，而模块的子模块对应的根文件夹则是父模块对应文件夹

模块中的代码默认是私有的，即使是对父模块也是私有的，如果需要声明公用模块，需要使用`pub mod`

使用模块中的成员，与C#使用对应名字空间中成员类似，直接使用完整路径，或者使用`use`(C#使用using关键字，不过F#也是使用use)导入对应的成员

导入（引入）对应模块，有两种路径方式：相对路径和绝对路径，相对路径和C#之类的类似，以当前路径作为起点进行查找；绝对路径则是从项目的最外层开始找，那么最外层是模块是什么呢？最外层模块就是`crate`，所以在使用时，如果以`crate`开头，就代表这个模块地址是绝对路径，从最外层开始查找

如果引入有两个相同的名称会冲突，这时候可以使用as关键字重命名

如果引入的名称也需要再导出（允许其它模块引入），可以使用`pub use`关键字

如果要引入外部包的模块，则use以包名为根

use可以嵌套，以消除大量的use行
```rust
// 合并嵌套写法
use std::{cmp::Ordering, io};

// 等效替代
use std::cmp::Ordering;
use std::io;
```

当嵌套写法有当前路径和子路径时，可以用self替代当前路径
```rust
use std::io::{self, Write};

// 等效替代
use std::io;
use std::io::Write;
```

如果要将所有的公有项引入作用域，可以指定路径后跟`*`
```rust
use std::collections::*;
```