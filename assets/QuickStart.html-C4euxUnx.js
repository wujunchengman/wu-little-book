import{_ as n,c as a,a as e,o as c}from"./app-Bah7_sEf.js";const l={};function i(p,s){return c(),a("div",null,s[0]||(s[0]=[e(`<h1 id="docker快速上手" tabindex="-1"><a class="header-anchor" href="#docker快速上手"><span>Docker快速上手</span></a></h1><h1 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile"><span>Dockerfile</span></a></h1><blockquote><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p></blockquote><p>一个简单的Dockerfile</p><div class="language-docker line-numbers-mode" data-highlighter="prismjs" data-ext="docker" data-title="docker"><pre><code><span class="line"><span class="token comment"># 拉取 mcr.microsoft.com/dotnet/sdk:6.0 镜像并将其命名为 build</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">FROM</span> mcr.microsoft.com/dotnet/sdk:6.0 <span class="token keyword">AS</span> build</span></span>
<span class="line"><span class="token comment"># 将镜像中的工作目录设置为 /src</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span></span>
<span class="line"><span class="token comment"># 将在本地找到的名为 backend.csproj 的文件复制到你创建的 /src 目录中</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">COPY</span> backend.csproj .</span></span>
<span class="line"><span class="token comment"># 在项目中调用 dotnet restore</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">RUN</span> dotnet restore</span></span>
<span class="line"><span class="token comment"># 将本地工作目录中的所有内容复制到镜像中</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">COPY</span> . .</span></span>
<span class="line"><span class="token comment"># 在项目中调用 dotnet publish</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">RUN</span> dotnet publish -c release -o /app</span></span>
<span class="line"><span class="token comment"># 拉取 mcr.microsoft.com/dotnet/aspnet:6.0 镜像</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">FROM</span> mcr.microsoft.com/dotnet/aspnet:6.0</span></span>
<span class="line"><span class="token comment"># 将镜像中的工作目录设置为 /app</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span></span>
<span class="line"><span class="token comment"># 公开端口 80 和 443</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">EXPOSE</span> 80</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">EXPOSE</span> 443</span></span>
<span class="line"><span class="token comment"># 将创建的 build 镜像的 /app 目录中的所有内容复制到此镜像的应用目录中</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">build</span></span> /app .</span></span>
<span class="line"><span class="token comment"># 将此镜像的入口点设置为 dotnet，并将 backend.dll 作为参数传递</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">&quot;dotnet&quot;</span>, <span class="token string">&quot;backend.dll&quot;</span>]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保存Dockerfile，然后进入到Dockerfile所在目录，执行下面指令</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> pizzabackend <span class="token builtin class-name">.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该Dockerfile覆盖了常见的指令，大多数情况下的Dockerfile都是这些指令，其中涉及了几个Docker的概念</p><h3 id="上下文路径" tabindex="-1"><a class="header-anchor" href="#上下文路径"><span>上下文路径</span></a></h3><p>无论是前面的Dockerfile还是创建docker镜像的命令，都包含了一个<code>.</code>，这个点代表的是当前上下文路径</p><p>它并不是固定的，而是根据命令所在的环境，如构建docker镜像时的<code>.</code>，所对应的环境是执行命令时的所在路径</p><p>而在上面的Dockerfile中，有这么一段</p><div class="language-docker line-numbers-mode" data-highlighter="prismjs" data-ext="docker" data-title="docker"><pre><code><span class="line"><span class="token comment"># 将镜像中的工作目录设置为 /src</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">WORKDIR</span> /src</span></span>
<span class="line"><span class="token comment"># 将在本地找到的名为 backend.csproj 的文件复制到你创建的 /src 目录中</span></span>
<span class="line"><span class="token instruction"><span class="token keyword">COPY</span> backend.csproj .</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>.</code>不再是执行命令的路径，而是上面的设置的工作目录，因为这里的参数是镜像中的路径，前面已经设置了镜像中的路径的上下文，因此这里指代的是<code>/src</code>工作目录</p><p>由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p><p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p><p>注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p><h3 id="工作目录" tabindex="-1"><a class="header-anchor" href="#工作目录"><span>工作目录</span></a></h3><p>当查找某个文件时，需要跳转到某个路径下执行，如果要删除一个文件，可以用rm命令</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">rm</span> test.txt</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如上面的命令，如果要删除<code>test.txt</code>，首先是进入到<code>test.txt</code>所在的目录，如果在本机上，可能是通过<code>cd</code>命令移动到对应的目录下，但是dockerfile中，使用<code>WORKDIR</code>切换到对应的目录，后续执行命令时，就以对应的工作目录作为当前路径</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><h3 id="公开端口" tabindex="-1"><a class="header-anchor" href="#公开端口"><span>公开端口</span></a></h3><p>Docker是轻量的虚拟机，因此很多东西与系统类似，系统中存在防火墙，只有开放的端口才能被外界访问到，如果外界需要访问对应的端口，就需要通过指令进行开放</p><h3 id="入口点" tabindex="-1"><a class="header-anchor" href="#入口点"><span>入口点</span></a></h3><p>入口点指的是启动镜像后执行的命令，它的参数与<code>RUN</code>命令类似，有两种写法，如果后面跟的是一个字符串，则是执行对应命令；如果是一个数组，则数组的第一个值是可执行程序，后面的值都是对应的参数</p>`,26)]))}const o=n(l,[["render",i]]),d=JSON.parse('{"path":"/Backend/Docker/QuickStart.html","title":"Docker快速上手","lang":"zh-CN","frontmatter":{"title":"Docker快速上手"},"headers":[{"level":3,"title":"上下文路径","slug":"上下文路径","link":"#上下文路径","children":[]},{"level":3,"title":"工作目录","slug":"工作目录","link":"#工作目录","children":[]},{"level":3,"title":"公开端口","slug":"公开端口","link":"#公开端口","children":[]},{"level":3,"title":"入口点","slug":"入口点","link":"#入口点","children":[]}],"git":{"updatedTime":1694698893000,"contributors":[{"name":"吴俊城","email":"wujunchengman@163.com","commits":1}]},"filePathRelative":"Backend/Docker/QuickStart.md"}');export{o as comp,d as data};
