import{_ as s,c as a,a as p,o as e}from"./app-Bah7_sEf.js";const t={};function c(l,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h1><p>Rust中的数据类型有两类，一类是标量类型，一类是复合类型</p><h2 id="标量类型" tabindex="-1"><a class="header-anchor" href="#标量类型"><span>标量类型</span></a></h2><p>标量类型所占的内存空间是确定的，是最基本的数据类型，这些类型在C#中称为基类型</p><p>标量类型包含整形、浮点型、布尔型、字符型</p><p>与其他编程语言一样，Rust的整形和浮点型也包含不同大小的细分类型，但是在Rust中，并不是用int表是32位整形、long表示64位整形，而是使用更直观的位表示</p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>isize 和 usize是根据架构来的，32位架构是32位，64位架构是64位</p><p>浮点数与其他编程语言一样分为32位浮点和64位浮点，不过并不叫float和double，而是叫f32和f64</p><p>布尔类型与其他编程语言一样，都是true和false；字符型表示一个字符，不过Rust中的字符是Unicode字符，占四个字节</p><h2 id="复合类型" tabindex="-1"><a class="header-anchor" href="#复合类型"><span>复合类型</span></a></h2><p>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）；还可以自定义类型</p><h3 id="元组" tabindex="-1"><a class="header-anchor" href="#元组"><span>元组</span></a></h3><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p><p>Rust中的元组和C#中的元组定义相似</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> tup<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">6.4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Rust中的元组还支持解构语法</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">=</span> tup<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>也可以通过<code>.</code>加索引值的方式访问元组中的值</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;通过索引值访问元组的第二个元素: {tup.1}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>不带任何值的元组有个特殊的名称，叫做 单元（unit） 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h3><p>数组中的每个元素类型必须相同，这与其他编程语言相同（排除掉已经不用的Object数组）。</p><p>声明数组的方式也是类似的，只是格式上有一点点不同</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token comment">// 声明包含5个i32元素的数组，但是没有初始化，直接访问会编译报错</span></span>
<span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 也可以直接提供具体的值声明一个数组，此时a也是一个包含5个元素的数组</span></span>
<span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 如果使用相同的元素初始化数组，可以在声明类型的地方替换为具体的值，后面元素数量的定义不变，会初始化为一个包含了指定数量，所有元素都初始化为提供的具体的值的数组</span></span>
<span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问数组中的元素使用对应的索引值</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> first <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> second <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序在索引操作中使用一个无效的值时导致<strong>运行时</strong>错误</p><p>如果需要访问一个不确定是否会越界的数组，可以使用get访问，它会返回一个Option，不会出现<strong>运行时</strong>错误</p><h3 id="列表-vector" tabindex="-1"><a class="header-anchor" href="#列表-vector"><span>列表（vector）</span></a></h3><p>vector 允许我们一个挨着一个地储存一系列数量可变的值。vector与其他编程语言的List类似</p><p>新建一个vector</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token comment">// 新建一个空vector</span></span>
<span class="line"><span class="token keyword">let</span> v<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 通过vec!宏创建含有指定元素的vector，泛型类型自动推断为i32</span></span>
<span class="line"><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 新建空vector并向其中增加元素</span></span>
<span class="line"><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问vector则与访问数组类似，可以通过索引和get访问</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 通过索引访问，如果不是合法的索引值，会导致运行时错误</span></span>
<span class="line"><span class="token keyword">let</span> third<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The third element is {third}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 通过get访问，返回一个Option，不会导致运行时错误</span></span>
<span class="line"><span class="token keyword">let</span> third<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">match</span> third <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Some</span><span class="token punctuation">(</span>third<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The third element is {third}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;There is no third element.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>vector不能在拥有其中项的引用的同时增加元素</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 编译器会报错，这是因为vector同其他编程语言一样，vector也是先申请一段空间以数组的方式保存，如果新增元素时容量不够，就申请一个更大的数组空间，将目前的元素复制过去</span></span>
<span class="line"><span class="token comment">// 如果在持有项的引用时添加元素导致了扩容复制，则原来的引用地址就不再有效</span></span>
<span class="line">v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>vector是泛型的，只能保存同一种类型，其他编程语言有非泛型List，但是Rust不提供，当有需要保存不同类型的元素在vector中的需求时，可以借助枚举类型，Rust的枚举类型非常特别，可以包含一个任意类型的值</p><h3 id="字符串-string" tabindex="-1"><a class="header-anchor" href="#字符串-string"><span>字符串（string）</span></a></h3><h3 id="哈希map-hash-map" tabindex="-1"><a class="header-anchor" href="#哈希map-hash-map"><span>哈希map（hash map）</span></a></h3><p>hashmap允许我们将值与一个特定的键（key）相关联。这是一个叫做 map 的更通用的数据结构的特定实现。</p>`,41)]))}const i=s(t,[["render",c]]),u=JSON.parse('{"path":"/Rust/DataTypes.html","title":"数据类型","lang":"zh-CN","frontmatter":{"title":"数据类型"},"headers":[{"level":2,"title":"标量类型","slug":"标量类型","link":"#标量类型","children":[]},{"level":2,"title":"复合类型","slug":"复合类型","link":"#复合类型","children":[{"level":3,"title":"元组","slug":"元组","link":"#元组","children":[]},{"level":3,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":3,"title":"列表（vector）","slug":"列表-vector","link":"#列表-vector","children":[]},{"level":3,"title":"字符串（string）","slug":"字符串-string","link":"#字符串-string","children":[]},{"level":3,"title":"哈希map（hash map）","slug":"哈希map-hash-map","link":"#哈希map-hash-map","children":[]}]}],"git":{"updatedTime":1745540110000,"contributors":[{"name":"吴俊城","email":"wujunchengman@163.com","commits":3}]},"filePathRelative":"Rust/DataTypes.md"}');export{i as comp,u as data};
